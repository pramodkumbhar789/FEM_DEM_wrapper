# Developed by 
# Pramod Kumbhar, Narasimhan Swaminathan, Ratna Kumar Annabattula
# Mesoscale analysis of Li-ion battery microstructure using sequential coupling of discrete element and finite element method.
# International Journal of Energy Research.


################################ Purpose #########################################
# For computing the boundary edges of the mesh
# in order to apply Neumann Boundary conditions we require the boundary edges of the mesh
##################################################################################

def boundary_nodes(file_number):
	import Tkinter as tk
	from tkFileDialog import askopenfilename as ask
	from tkFileDialog import askdirectory as askdir
	import os
	import matplotlib.pyplot as plt
	from mpl_toolkits.mplot3d import Axes3D
	import matplotlib
	import numpy as np
	import time
	import math
	from mpl_toolkits.mplot3d import Axes3D
	from matplotlib import cm
	from matplotlib.ticker import LinearLocator, FormatStrFormatter
	from matplotlib.pyplot import *
	from math import pi
	import itertools
	#import numpy_indexed as npi

	## The below portion of the code reads the .inp file generated by ABAQUS. 
	## sorts the data nodewise and elementwise and
	## plots the boundary of the mesh of each group
	## All the edge information is then stored in the variable edges. 


	data_file="Job_"+str(file_number)+".inp" #input('Enter file name') # Enter the .inp file name whose boundary is to be computed.
	#data_file=open('Job_dummy.inp') # Enter the .inp file name whose boundary is to be computed.
	input_data=[]
	node_number=[]
	all_nodes=[]
	x_node=[]
	y_node=[]

	## All the information from the inp file is stored linewise
	with open(data_file) as f:
		for line in f:
			input_data.append(line.strip().split(','))
		
		
	## the line that reads the first node of the mesh info in the .inp file is found and line number is stored in the variable first_node
	lookup="*Node"
	with open(data_file) as myFile:
	    for num, line in enumerate(myFile, 1):
		if lookup in line:
		    first_node = num
	#raise SystemExit
	## The line that reads the first element of the mesh  in the .inp file is found.
	## The line number is stored in the variable first_element and the line that reads the last node is stored in the variable last_node
	lookup="*Element"
	with open(data_file) as myFile:
	    for num, line in enumerate(myFile, 1):
		if lookup in line:
		    first_element = num 
		    last_node=first_element -1

	lookup="*Element"
	with open(data_file) as myFile:
	    for num, line in enumerate(myFile, 1):
		if lookup in line:
		    first_element = num 
		    last_node=first_element -1

	## The line that reads the last element information of the mesh  in the .inp file is found and line number is stored in the variable last_element
	lookup="*End Part"
	with open(data_file) as myFile:
	    for num, line in enumerate(myFile, 1):
		if lookup in line:
		    last_element = num -1

	## The X coordinate of all the nodes is stored in the variable x_node
	for i in range(first_node,last_node):
		x_node.append(float(input_data[i][1]))
		
	## The Y coordinate of all the nodes is stored in the variable y_node
	for i in range(first_node,last_node):
		y_node.append(float(input_data[i][2]))	
	

	for i in range(first_element,last_element):
		 all_nodes.append (input_data[i])

	elem_edges =[]
	elem_info = []
	elem_info1 = []
	Sum_elem=[]	  
	Sub_elem=[]	  
	e=[]
	e1=[]
	econ=[]
	# The element connectivity is appended in this section to get element edges for a T6 element in a anti-clockwise order i.e. 1-4-2-5-3-6.
	#		 3
	#		 /\
	#		/  \
	#	   /    \
	#	  6      5
	#	 /        \
	#   /          \
	#  /    	    \
	# 1------4-------2
	# The variable econ is defined to store element connecticity of all the elements in the mesh.

	for i in range(0,last_element-first_element):
		a1 = all_nodes[i][1], all_nodes[i][4], all_nodes[i][2], all_nodes[i][5], all_nodes[i][3], all_nodes[i][6] 
		econ.append(a1)
	
	#In this section the element edges are stored for each element in th anticlockwise order i.e. 14-42-25-53-36-61
	# This is done to get edges of all elements which are a key ingredient to further calculations.
	
	for i in range(0,last_element-first_element):
		 for j in range (0,6):
			if j < 5:	
				e1 = econ[i][j], econ[i][j+1] 
				elem_edges.append(e1)
			elif j == 5:
				e1 = econ[i][j] , econ[i][0] 
				elem_edges.append(e1)
			
	# For all the edges of the element the following information is stored in the variable elem_info i.e.
	# (sum of the node number that form the edge, absolute value of subtraction of the node number that form the edge,subtraction of the node number that form the edge)
	# Example: for edge "14"	the elem_info entry would be [1+4,abs(1-4), 1-4]	
						
	for i in range(0,len(elem_edges)):
		Sum_e = int(elem_edges[i][0]) + int(elem_edges[i][1])
		Sum_elem.append(Sum_e)
		Sub_e = int(elem_edges[i][0]) - int(elem_edges[i][1])
		Sub_elem.append(Sub_e)
		d = Sum_elem[i] , abs(Sub_elem[i]) ,Sub_elem[i]
		elem_info.append(d)
	# Once the element info is stored in a variable we get the unique entreis of the first two colums of elem_info i.e
	#(sum of the node number that form the edge, absolute value of subtraction of the node number that form the edge)
	# Example: for edge "14"	the elem_info entry would be [1+4,abs(1-4)] ojnly the first two colums of the elem info are used to get frequency of occurencce of element edges 
	# "The Logic: If the frequency of occurence of an element edge is 1 then that element lies on the boundary of the domain, 
	# this implies that the element edges on the boundary are not shared with any other element and hence their frequency should be 1 if edge lies on boundary"
	# after having obtained the unique values, their frequency of occurence and their index in the variable elem_info we use this information to extract 

	elem_info_array = np.asarray(elem_info)
	sum_abs_sub = elem_info_array[0:,0:2]
	dt = np.dtype((np.void, sum_abs_sub.dtype.itemsize * sum_abs_sub.shape[1]))
	b = np.ascontiguousarray(sum_abs_sub).view(dt)
	unq, pos, inv, indic = np.unique(b, return_counts=True, return_inverse=True, return_index=True)
	cnt = np.bincount(inv)
	unq = unq.view(sum_abs_sub.dtype).reshape(-1, sum_abs_sub.shape[1])

	Bound_edge=[]
	Boundary=[]    
		                                                                                                                  
	# Now the variable Bound_edge is defined to store addition and subtraction of each unique edge. 
	# Theis information is accesses based on the frequency and index obtaioned fron above. i.e. unq and cnt.

	for i in range (0,len(cnt)):
		if cnt[i] == 1 :
			B = unq[i][0],elem_info_array[int(pos[i])][2]
			Bound_edge.append(B)

	# here we define A for AX=B  where A is the coeffecient of the algebrix equations being solved.
	# Here are solving x+y=a and x-y=b i.e we know sum dand subtraction of unqiue nodes and we have to compute the node number by solving these algebric equations.
	# X = inx(A)*B is solved to get X hence we compute inverse of A

	A =np.matrix([[1,1],[1,-1]])
	A_inv = np.linalg.inv(A)
	Edges =[]
	for i in range (0, len(Bound_edge)):
		X = np.matrix([Bound_edge[i][0],Bound_edge[i][1]])
		Xt= X.transpose()
		#raise SystemExit
		Sol = A_inv * Xt
		#raise SystemExit
		Edges.append(Sol)

	# After having obtained the node numbers for all boundary edges we append the coordinates of all boundary edges in bound_x and bound_y.

	bound_x =[]
	bound_y=[]
	node = set([])
	for i in range (0,len(Edges)):
		bound_x.append(x_node[int(Edges[i][0])-1])
		bound_x.append(x_node[int(Edges[i][1])-1])
		bound_y.append(y_node[int(Edges[i][0])-1])
		bound_y.append(y_node[int(Edges[i][1])-1])
		node.add(int(Edges[i][0]))
		node.add(int(Edges[i][1]))

	##### Here we plot the boundary edges.	
	#figure()
	#axis('equal')
	#plot(x_node,y_node, '.b')
	#plt.plot(bound_x,bound_y, '.r')
	#plt.pause(0.02)
	#time.sleep(0.02)
	#show()
	return node
